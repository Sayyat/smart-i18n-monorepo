import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { loadConfig } from '../../../src/lib/config';
import * as fs from 'node:fs/promises';
import { createJiti } from 'jiti';

// 1. Mock external modules
vi.mock('node:fs/promises');
vi.mock('jiti');

// Mock Logger
const mockLogger = {
	info: vi.fn(),
	warn: vi.fn(),
	error: vi.fn(),
};

describe('loadConfig', () => {
	// Mock function for jiti.import
	const mockJitiImport = vi.fn();

	beforeEach(() => {
		vi.resetAllMocks();

		// Setup createJiti to return our mock import function
		(createJiti as any).mockReturnValue({
			import: mockJitiImport,
		});
	});

	afterEach(() => {
		vi.restoreAllMocks();
	});

	it('Should return null and log error if specific config file is not found', async () => {
		// Mock fs.access to reject (simulate file not found)
		vi.mocked(fs.access).mockRejectedValue(new Error('ENOENT'));

		const config = await loadConfig('missing.config.ts', mockLogger);

		expect(config).toBeNull();
		// Updated expectation to match actual log message format
		expect(mockLogger.error).toHaveBeenCalledWith(
			expect.stringContaining('Error: Config file not found at')
		);
	});

	it('Should return null and log info if NO config file is found (default search)', async () => {
		// Mock fs.access to reject for all default file checks
		vi.mocked(fs.access).mockRejectedValue(new Error('ENOENT'));

		const config = await loadConfig(undefined, mockLogger);

		expect(config).toBeNull();
		// Updated expectation to match actual log message format
		expect(mockLogger.info).toHaveBeenCalledWith(
			expect.stringContaining('Config file not found')
		);
	});

	it('Should load TS config via jiti and apply defaults', async () => {
		// 1. Mock fs.access to resolve only for 'i18next.config.ts'
		vi.mocked(fs.access).mockImplementation(async (p) => {
			if (typeof p === 'string' && p.endsWith('i18next.config.ts')) {
				return Promise.resolve();
			}
			return Promise.reject();
		});

		// 2. Mock jiti.import to return a valid config
		const mockUserConfig = {
			locales: ['en', 'ru', 'kk'],
			// 'extract' is missing, should be auto-generated by loadConfig
		};
		mockJitiImport.mockResolvedValue({ default: mockUserConfig });

		const config = await loadConfig(undefined, mockLogger);

		// 3. Assertions
		expect(config).not.toBeNull();
		expect(config?.locales).toEqual(['en', 'ru', 'kk']);

		// Verify that 'extract' object and defaults were applied
		expect(config?.extract).toBeDefined();
		expect(config?.extract.primaryLanguage).toBe('en'); // defaults to locales[0]
		expect(config?.extract.secondaryLanguages).toEqual(['ru', 'kk']); // rest of locales
	});

	it('Should respect user provided extract options', async () => {
		vi.mocked(fs.access).mockImplementation(async (p) => {
			if (typeof p === 'string' && p.endsWith('i18next.config.ts')) return Promise.resolve();
			return Promise.reject();
		});

		const mockUserConfig = {
			locales: ['en', 'fr'],
			extract: {
				primaryLanguage: 'fr', // User explicitly sets this
			}
		};
		mockJitiImport.mockResolvedValue({ default: mockUserConfig });

		const config = await loadConfig(undefined, mockLogger);

		// Verify user's choice is respected
		expect(config?.extract.primaryLanguage).toBe('fr');
		// Verify secondary languages are calculated correctly based on user's primary language
		expect(config?.extract.secondaryLanguages).toEqual(['en']);
	});

	it('Should return null if config has no default export', async () => {
		vi.mocked(fs.access).mockResolvedValue(undefined); // File exists

		// Mock jiti to return empty object (no default export)
		mockJitiImport.mockResolvedValue({});

		const config = await loadConfig('i18next.config.ts', mockLogger);

		expect(config).toBeNull();
		// Updated expectation to match actual log message format
		expect(mockLogger.error).toHaveBeenCalledWith(
			expect.stringContaining('Error: No default export found')
		);
	});

	it('Should handle errors during Jiti import', async () => {
		vi.mocked(fs.access).mockResolvedValue(undefined);

		// Mock jiti to throw an error (e.g., syntax error in config file)
		mockJitiImport.mockRejectedValue(new Error('Syntax Error'));

		const config = await loadConfig('i18next.config.ts', mockLogger);

		expect(config).toBeNull();
		// Updated expectation to match actual log message format
		expect(mockLogger.error).toHaveBeenCalledWith(
			expect.stringContaining('Error loading configuration')
		);
	});
});